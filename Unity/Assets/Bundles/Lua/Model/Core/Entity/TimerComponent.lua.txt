-- Generated by CSharp.lua Compiler
local System = System
local ET = ET
local QueueInt64 = System.Queue(System.Int64)
local ETTask_1Boolean = ET.ETTask_1(System.Boolean)
local ET
local MultiMap_2Int64Int64
System.import(function (out)
  ET = out.ET
  MultiMap_2Int64Int64 = ET.MultiMap_2(System.Int64, System.Int64)
end)
System.namespace("ET", function (namespace)
  namespace.enum("TimerClass", function ()
    local class
    class = {
      None = 0,
      OnceWaitTimer = 1,
      OnceTimer = 2,
      RepeatedTimer = 3,
      __metadata__ = function (out)
        return {
          fields = {
            { "None", 0xE, class },
            { "OnceTimer", 0xE, class },
            { "OnceWaitTimer", 0xE, class },
            { "RepeatedTimer", 0xE, class }
          },
          class = { 0x6 }
        }
      end
    }
    return class
  end)

  namespace.class("TimerActionAwakeSystem", function (namespace)
    local Awake
    Awake = function (this, self, timerClass, time, callback)
      self.TimerClass = timerClass
      self.Callback = callback
      self.Time = time
    end
    return {
      base = function (out)
        return {
          out.ET.AwakeSystem_4(out.ET.TimerAction, out.ET.TimerClass, System.Int64, System.Object)
        }
      end,
      Awake = Awake,
      __metadata__ = function (out)
        return {
          methods = {
            { "Awake", 0x406, Awake, out.ET.TimerAction, out.ET.TimerClass, System.Int64, System.Object }
          },
          class = { 0x6, out.ET.ObjectSystemAttribute() }
        }
      end
    }
  end)

  namespace.class("TimerActionDestroySystem", function (namespace)
    local Destroy
    Destroy = function (this, self)
      self.Callback = nil
      self.Time = 0
      self.TimerClass = ET.TimerClass.None
    end
    return {
      base = function (out)
        return {
          out.ET.DestroySystem_1(out.ET.TimerAction)
        }
      end,
      Destroy = Destroy,
      __metadata__ = function (out)
        return {
          methods = {
            { "Destroy", 0x106, Destroy, out.ET.TimerAction }
          },
          class = { 0x6, out.ET.ObjectSystemAttribute() }
        }
      end
    }
  end)

  namespace.class("TimerAction", function (namespace)
    local __ctor__
    __ctor__ = function (this)
      this.TimerClass = ET.TimerClass.None
      ET.Entity.__ctor__(this)
    end
    return {
      base = function (out)
        return {
          out.ET.Entity
        }
      end,
      Time = 0,
      __ctor__ = __ctor__,
      __metadata__ = function (out)
        return {
          fields = {
            { "Callback", 0x6, System.Object },
            { "Time", 0x6, System.Int64 },
            { "TimerClass", 0x6, out.ET.TimerClass }
          },
          class = { 0x6 }
        }
      end
    }
  end)

  namespace.class("TimerComponentAwakeSystem", function (namespace)
    local Awake
    Awake = function (this, self)
      ET.TimerComponent.Instance = self
    end
    return {
      base = function (out)
        return {
          out.ET.AwakeSystem_1(out.ET.TimerComponent)
        }
      end,
      Awake = Awake,
      __metadata__ = function (out)
        return {
          methods = {
            { "Awake", 0x106, Awake, out.ET.TimerComponent }
          },
          class = { 0x6, out.ET.ObjectSystemAttribute() }
        }
      end
    }
  end)

  namespace.class("TimerComponentUpdateSystem", function (namespace)
    local Update
    Update = function (this, self)
      self:Update()
    end
    return {
      base = function (out)
        return {
          out.ET.UpdateSystem_1(out.ET.TimerComponent)
        }
      end,
      Update = Update,
      __metadata__ = function (out)
        return {
          methods = {
            { "Update", 0x106, Update, out.ET.TimerComponent }
          },
          class = { 0x6, out.ET.ObjectSystemAttribute() }
        }
      end
    }
  end)

  namespace.class("TimerComponent", function (namespace)
    local Update, Run, AddTimer, WaitTillAsync, WaitFrameAsync, WaitAsync, NewFrameTimer, NewRepeatedTimerInner, 
    NewRepeatedTimer, Remove, Remove1, NewOnceTimer, class, __ctor__
    __ctor__ = function (this)
      this.TimeId = MultiMap_2Int64Int64()
      this.timeOutTime = QueueInt64()
      this.timeOutTimerIds = QueueInt64()
      ET.Entity.__ctor__(this)
    end
    Update = function (this)
      if this.TimeId:getCount() == 0 then
        return
      end

      local timeNow = ET.TimeHelper.ServerNow()

      if timeNow < this.minTime then
        return
      end

      for _, kv in System.each(this.TimeId) do
        local k = kv.Key
        if k > timeNow then
          this.minTime = k
          break
        end

        this.timeOutTime:Enqueue(k)
      end

      while #this.timeOutTime > 0 do
        local time = this.timeOutTime:Dequeue()
        for _, timerId in System.each(this.TimeId:get1(time)) do
          this.timeOutTimerIds:Enqueue(timerId)
        end

        this.TimeId:RemoveKey(time)
      end

      while #this.timeOutTimerIds > 0 do
        local continue
        repeat
          local timerId = this.timeOutTimerIds:Dequeue()

          local timerAction = this:GetChild(timerId, ET.TimerAction)
          if timerAction == nil then
            continue = true
            break
          end
          Run(this, timerAction)
          continue = true
        until 1
        if not continue then
          break
        end
      end
    end
    Run = function (this, timerAction)
      repeat
        local default = timerAction.TimerClass
        if default == ET.TimerClass.OnceWaitTimer then
          local tcs = System.as(timerAction.Callback, ETTask_1Boolean)
          Remove1(this, timerAction.Id)
          tcs:SetResult(true)
          break
        elseif default == ET.TimerClass.OnceTimer then
          local action = System.as(timerAction.Callback, System.Delegate)
          Remove1(this, timerAction.Id)
          local extern = action
          if extern ~= nil then
            extern()
          end
          break
        elseif default == ET.TimerClass.RepeatedTimer then
          local action = System.as(timerAction.Callback, System.Delegate)
          local tillTime = ET.TimeHelper.ServerNow() + timerAction.Time
          AddTimer(this, tillTime, timerAction)
          local extern = action
          if extern ~= nil then
            extern()
          end
          break
        end
      until 1
    end
    AddTimer = function (this, tillTime, timer)
      this.TimeId:Add(tillTime, timer.Id)
      if tillTime < this.minTime then
        this.minTime = tillTime
      end
    end
    WaitTillAsync = function (this, tillTime, cancellationToken)
      return System.async(function (async, this, tillTime, cancellationToken)
        if ET.TimeHelper.ServerNow() >= tillTime then
          return true
        end

        local tcs = ETTask_1Boolean.Create(true)
        local timer = ET.EntityFactory.CreateWithParent3(this, ET.TimerClass.OnceWaitTimer, 0, tcs, true, ET.TimerAction, ET.TimerClass, System.Int64, System.Object)
        AddTimer(this, tillTime, timer)
        local timerId = timer.Id

        local function CancelAction() 
          if Remove1(this, timerId) then
            tcs:SetResult(false)
          end
        end

        local ret
        System.try(function ()
          local default = cancellationToken
          if default ~= nil then
            default:Add(CancelAction)
          end
          ret = async:Await(tcs)
        end, nil, function ()
          local default = cancellationToken
          if default ~= nil then
            default:Remove(CancelAction)
          end
        end)
        return ret
      end, nil, this, tillTime, cancellationToken)
    end
    WaitFrameAsync = function (this, cancellationToken)
      return System.async(function (async, this, cancellationToken)
        return async:Await(WaitAsync(this, 1, cancellationToken))
      end, nil, this, cancellationToken)
    end
    WaitAsync = function (this, time, cancellationToken)
      return System.async(function (async, this, time, cancellationToken)
        if time == 0 then
          return true
        end
        local tillTime = ET.TimeHelper.ServerNow() + time

        local tcs = ETTask_1Boolean.Create(true)

        local timer = ET.EntityFactory.CreateWithParent3(this, ET.TimerClass.OnceWaitTimer, 0, tcs, true, ET.TimerAction, ET.TimerClass, System.Int64, System.Object)
        AddTimer(this, tillTime, timer)
        local timerId = timer.Id

        local function CancelAction() 
          if Remove1(this, timerId) then
            tcs:SetResult(false)
          end
        end

        local ret
        System.try(function ()
          local default = cancellationToken
          if default ~= nil then
            default:Add(CancelAction)
          end
          ret = async:Await(tcs)
        end, nil, function ()
          local default = cancellationToken
          if default ~= nil then
            default:Remove(CancelAction)
          end
        end)
        return ret
      end, nil, this, time, cancellationToken)
    end
    NewFrameTimer = function (this, action)
      return NewRepeatedTimerInner(this, 1, action)
    end
    -- <summary>
    -- 创建一个RepeatedTimer
    -- </summary>
    NewRepeatedTimerInner = function (this, time, action)
      ET.Log.Debug("NewRepeatedTimerInner")
      local tillTime = ET.TimeHelper.ServerNow() + time
      local timer = ET.EntityFactory.CreateWithParent3(this, ET.TimerClass.RepeatedTimer, time, action, true, ET.TimerAction, ET.TimerClass, System.Int64, System.Object)
      AddTimer(this, tillTime, timer)
      return timer.Id
    end
    NewRepeatedTimer = function (this, time, action)
      return NewRepeatedTimerInner(this, time, action)
    end
    Remove = function (this, id)
      Remove1(this, id)
      id = 0
      return id
    end
    Remove1 = function (this, id)
      if id == 0 then
        return false
      end

      local timerAction = this:GetChild(id, ET.TimerAction)
      if timerAction == nil then
        return false
      end
      timerAction:Dispose()
      return true
    end
    NewOnceTimer = function (this, tillTime, action)
      if tillTime < ET.TimeHelper.ServerNow() then
        ET.Log.Error("new once time too small: " .. tillTime)
      end
      local timer = ET.EntityFactory.CreateWithParent3(this, ET.TimerClass.OnceTimer, 0, action, true, ET.TimerAction, ET.TimerClass, System.Int64, System.Object)
      AddTimer(this, tillTime, timer)
      return timer.Id
    end
    class = {
      base = function (out)
        return {
          out.ET.Entity
        }
      end,
      minTime = 0,
      Update = Update,
      WaitTillAsync = WaitTillAsync,
      WaitFrameAsync = WaitFrameAsync,
      WaitAsync = WaitAsync,
      NewFrameTimer = NewFrameTimer,
      NewRepeatedTimer = NewRepeatedTimer,
      Remove = Remove,
      Remove1 = Remove1,
      NewOnceTimer = NewOnceTimer,
      __ctor__ = __ctor__,
      __metadata__ = function (out)
        return {
          properties = {
            { "Instance", 0xE, class }
          },
          fields = {
            { "minTime", 0x1, System.Int64 },
            { "TimeId", 0x1, out.ET.MultiMap_2(System.Int64, System.Int64) },
            { "timeOutTime", 0x1, System.Queue(System.Int64) },
            { "timeOutTimerIds", 0x1, System.Queue(System.Int64) }
          },
          methods = {
            { "AddTimer", 0x201, AddTimer, System.Int64, out.ET.TimerAction },
            { "NewFrameTimer", 0x186, NewFrameTimer, System.Delegate, System.Int64 },
            { "NewOnceTimer", 0x286, NewOnceTimer, System.Int64, System.Delegate, System.Int64 },
            { "NewRepeatedTimer", 0x286, NewRepeatedTimer, System.Int64, System.Delegate, System.Int64 },
            { "NewRepeatedTimerInner", 0x281, NewRepeatedTimerInner, System.Int64, System.Delegate, System.Int64 },
            { "Remove", 0x106, Remove, System.Int64 },
            { "Remove", 0x186, Remove1, System.Int64, System.Boolean },
            { "Run", 0x101, Run, out.ET.TimerAction },
            { "Update", 0x6, Update },
            { "WaitAsync", 0x286, WaitAsync, System.Int64, out.ET.ETCancellationToken, out.ET.ETTask_1(System.Boolean) },
            { "WaitFrameAsync", 0x186, WaitFrameAsync, out.ET.ETCancellationToken, out.ET.ETTask_1(System.Boolean) },
            { "WaitTillAsync", 0x286, WaitTillAsync, System.Int64, out.ET.ETCancellationToken, out.ET.ETTask_1(System.Boolean) }
          },
          class = { 0x6 }
        }
      end
    }
    return class
  end)
end)
