-- Generated by CSharp.lua Compiler
local System = System
local Linq = System.Linq.Enumerable
local ETCold = ETCold
local SystemNet = System.Net
local SystemNetSockets = System.Net.Sockets
local SystemInteropServices = System.Runtime.InteropServices
local ArrayByte = System.Array(System.Byte)
local ListInt64 = System.List(System.Int64)
local HashSetInt64 = System.HashSet(System.Int64)
local ET
local DictInt64KChannel
local ListComponent_1Int64
local MultiMap_2Int64Int64
System.import(function (out)
  ET = out.ET
  DictInt64KChannel = System.Dictionary(System.Int64, ET.KChannel)
  ListComponent_1Int64 = ET.ListComponent_1(System.Int64)
  MultiMap_2Int64Int64 = ET.MultiMap_2(System.Int64, System.Int64)
end)
System.namespace("ET", function (namespace)
  namespace.class("KcpProtocalType", function (namespace)
    return {
      __metadata__ = function (out)
        return {
          class = { 0xE }
        }
      end
    }
  end)

  namespace.enum("ServiceType", function ()
    local class
    class = {
      Outer = 0,
      Inner = 1,
      __metadata__ = function (out)
        return {
          fields = {
            { "Inner", 0xE, class },
            { "Outer", 0xE, class }
          },
          class = { 0x6 }
        }
      end
    }
    return class
  end)

  namespace.class("KService", function (namespace)
    local getTimeNow, logBuffer, KcpLog, KcpOutput, ChangeAddress, IsDispose, Dispose, CloneAddress, 
    Recv, Get1, GetByLocalConn, Get, Remove, Disconnect, Send, AddToUpdateNextTime, 
    Update, RemoveConnectTimeoutChannels, TimerOut, static, internal, __ctor1__, __ctor2__
    static = function (this)
      logBuffer = ArrayByte:new(1024)
      --Kcp.KcpSetLog(KcpLog);
      ETCold.Kcp.KcpSetoutput(KcpOutput)
    end
    internal = function (this)
      this.idChannels = DictInt64KChannel()
      this.localConnChannels = DictInt64KChannel()
      this.waitConnectChannels = DictInt64KChannel()
      this.cache = ArrayByte:new(8192)
      this.ipEndPoint = SystemNet.IPEndPoint(SystemNet.IPAddress.Any, 0)
      this.updateChannels = HashSetInt64()
      this.timeId = MultiMap_2Int64Int64()
      this.timeOutTime = ListInt64()
    end
    __ctor1__ = function (this, threadSynchronizationContext, ipEndPoint, serviceType)
      internal(this)
      System.base(this).__ctor__(this)
      this.ServiceType = serviceType
      this.ThreadSynchronizationContext = threadSynchronizationContext
      this.startTime = ET.TimeHelper.ClientNow()
      this.socket = SystemNetSockets.Socket(SystemNetSockets.AddressFamily.InterNetwork, SystemNetSockets.SocketType.Dgram, SystemNetSockets.ProtocolType.Udp)
      if not SystemInteropServices.RuntimeInformation.IsOSPlatform(SystemInteropServices.OSPlatform.getOSX()) then
        this.socket:setSendBufferSize(67108864 --[[Kcp.OneM * 64]])
        this.socket:setReceiveBufferSize(67108864 --[[Kcp.OneM * 64]])
      end

      this.socket:Bind(ipEndPoint)
      if SystemInteropServices.RuntimeInformation.IsOSPlatform(SystemInteropServices.OSPlatform.getWindows()) then
        local SIO_UDP_CONNRESET = 2550136844 --[[IOC_IN | IOC_VENDOR | 12]]
        this.socket:IOControl(System.toInt32(SIO_UDP_CONNRESET), ArrayByte(System.Convert.ToByte(false)), nil)
      end
    end
    __ctor2__ = function (this, threadSynchronizationContext, serviceType)
      internal(this)
      System.base(this).__ctor__(this)
      this.ServiceType = serviceType
      this.ThreadSynchronizationContext = threadSynchronizationContext
      this.startTime = ET.TimeHelper.ClientNow()
      this.socket = SystemNetSockets.Socket(SystemNetSockets.AddressFamily.InterNetwork, SystemNetSockets.SocketType.Dgram, SystemNetSockets.ProtocolType.Udp)
      -- 作为客户端不需要修改发送跟接收缓冲区大小
      this.socket:Bind(SystemNet.IPEndPoint(SystemNet.IPAddress.Any, 0))

      if SystemInteropServices.RuntimeInformation.IsOSPlatform(SystemInteropServices.OSPlatform.getWindows()) then
        local SIO_UDP_CONNRESET = 2550136844 --[[IOC_IN | IOC_VENDOR | 12]]
        this.socket:IOControl(System.toInt32(SIO_UDP_CONNRESET), ArrayByte(System.Convert.ToByte(false)), nil)
      end
    end
    getTimeNow = function (this)
      return System.toUInt32(ET.TimeHelper.ClientNow() - this.startTime)
    end
    KcpLog = function (bytes, len, kcp, user)
      System.try(function ()
        SystemInteropServices.Marshal.Copy(bytes, logBuffer, 0, len)
        ET.Log.Info(ETCold.ByteHelper.ToStr(logBuffer, 0, len))
      end, function (default)
        local e = default
        ET.Log.Error1(e)
      end)
    end
    KcpOutput = function (bytes, len, kcp, user)
      local default, extern = System.try(function ()
        if kcp == System.IntPtr.Zero then
          return true, 0
        end

        local default, kChannel = ET.KChannel.KcpPtrChannels:TryGetValue(kcp)
        if not default then
          return true, 0
        end

        kChannel:Output(bytes, len)
      end, function (default)
        local e = default
        ET.Log.Error1(e)
        return true, len
      end)
      if default then
        return extern
      end

      return len
    end
    ChangeAddress = function (this, id, address)
      local kChannel = Get1(this, id)
      if kChannel == nil then
        return
      end

      ET.Log.Info("channel change address: " .. id .. " " .. System.toString(address))
      kChannel.RemoteAddress = address
    end
    IsDispose = function (this)
      return this.socket == nil
    end
    Dispose = function (this)
      for _, channelId in System.each(Linq.ToArray(this.idChannels:getKeys())) do
        Remove(this, channelId)
      end

      this.socket:Close()
      this.socket = nil
    end
    CloneAddress = function (this)
      local ip = System.cast(SystemNet.IPEndPoint, this.ipEndPoint)
      return SystemNet.IPEndPoint(ip:getAddress(), ip:getPort())
    end
    Recv = function (this)
      if this.socket == nil then
        return
      end

      while this.socket ~= nil and this.socket:getAvailable() > 0 do
        local continue
        repeat
          local default
          default, this.ipEndPoint = this.socket:ReceiveFrom(this.cache, this.ipEndPoint)
          local messageLength = default

          -- 长度小于1，不是正常的消息
          if messageLength < 1 then
            continue = true
            break
          end

          -- accept
          local flag = this.cache:get(0)

          -- conn从100开始，如果为1，2，3则是特殊包
          local remoteConn = 0
          local localConn = 0

          System.try(function ()
            local kChannel = nil
            repeat
              local default = flag
              if default == 2 --[[KcpProtocalType.ACK]] then
                -- connect返回
                -- 长度!=9，不是connect消息
                if messageLength ~= 9 then
                  break
                end

                remoteConn = System.BitConverter.ToUInt32(this.cache, 1)
                localConn = System.BitConverter.ToUInt32(this.cache, 5)
                kChannel = GetByLocalConn(this, localConn)
                if kChannel ~= nil then
                  ET.Log.Info("kservice ack: " .. kChannel.Id .. " " .. remoteConn .. " " .. localConn)
                  kChannel.RemoteConn = remoteConn
                  kChannel:HandleConnnect()
                end

                break
              elseif default == 3 --[[KcpProtocalType.FIN]] then
                -- 断开
                -- 长度!=13，不是DisConnect消息
                if messageLength ~= 13 then
                  break
                end

                remoteConn = System.BitConverter.ToUInt32(this.cache, 1)
                localConn = System.BitConverter.ToUInt32(this.cache, 5)
                local error = System.BitConverter.ToInt32(this.cache, 9)

                -- 处理chanel
                kChannel = GetByLocalConn(this, localConn)
                if kChannel == nil then
                  break
                end

                -- 校验remoteConn，防止第三方攻击
                if kChannel.RemoteConn ~= remoteConn then
                  break
                end

                ET.Log.Info("kservice recv fin: " .. kChannel.Id .. " " .. localConn .. " " .. remoteConn .. " " .. error)
                kChannel:OnError(100208 --[[ErrorCode.ERR_PeerDisconnect]])

                break
              elseif default == 4 --[[KcpProtocalType.MSG]] then
                -- 断开
                -- 长度<9，不是Msg消息
                if messageLength < 9 then
                  break
                end
                -- 处理chanel
                remoteConn = System.BitConverter.ToUInt32(this.cache, 1)
                localConn = System.BitConverter.ToUInt32(this.cache, 5)

                kChannel = GetByLocalConn(this, localConn)
                if kChannel == nil then
                  -- 通知对方断开
                  Disconnect(this, localConn, remoteConn, 100216 --[[ErrorCode.ERR_KcpNotFoundChannel]], System.cast(SystemNet.IPEndPoint, this.ipEndPoint), 1)
                  break
                end

                -- 校验remoteConn，防止第三方攻击
                if kChannel.RemoteConn ~= remoteConn then
                  break
                end

                kChannel:HandleRecv(this.cache, 5, messageLength - 5)
                break
              end
            until 1
          end, function (default)
            local e = default
            ET.Log.Error("kservice error: " .. flag .. " " .. remoteConn .. " " .. localConn .. "\n" .. System.toString(e))
          end)
          continue = true
        until 1
        if not continue then
          break
        end
      end
    end
    Get1 = function (this, id)
      local channel
      local _
      _, channel = this.idChannels:TryGetValue(id)
      return channel
    end
    GetByLocalConn = function (this, localConn)
      local channel
      local _
      _, channel = this.localConnChannels:TryGetValue(localConn)
      return channel
    end
    Get = function (this, id, address)
      local default, kChannel = this.idChannels:TryGetValue(id)
      if default then
        return
      end

      System.try(function ()
        -- 低32bit是localConn
        local localConn = System.toUInt32(System.band(System.toUInt64(id), 4294967295 --[[UInt32.MaxValue]]))
        kChannel = ET.KChannel(id, localConn, this.socket, address, this)
        this.idChannels:AddKeyValue(id, kChannel)
        this.localConnChannels:AddKeyValue(kChannel.LocalConn, kChannel)
      end, function (default)
        local e = default
        ET.Log.Error("kservice get error: " .. id .. "\n" .. System.toString(e))
      end)
    end
    Remove = function (this, id)
      local default, kChannel = this.idChannels:TryGetValue(id)
      if not default then
        return
      end
      ET.Log.Info("kservice remove channel: " .. id .. " " .. kChannel.LocalConn .. " " .. kChannel.RemoteConn)
      this.idChannels:RemoveKey(id)
      this.localConnChannels:RemoveKey(kChannel.LocalConn)
      local extern, waitChannel = this.waitConnectChannels:TryGetValue(kChannel.RemoteConn)
      if extern then
        if waitChannel.LocalConn == kChannel.LocalConn then
          this.waitConnectChannels:RemoveKey(kChannel.RemoteConn)
        end
      end
      kChannel:Dispose()
    end
    Disconnect = function (this, localConn, remoteConn, error, address, times)
      local default = System.try(function ()
        if this.socket == nil then
          return true
        end

        local buffer = this.cache
        ETCold.ByteHelper.WriteTo(buffer, 0, 3 --[[KcpProtocalType.FIN]])
        ETCold.ByteHelper.WriteTo(buffer, 1, localConn)
        ETCold.ByteHelper.WriteTo(buffer, 5, remoteConn)
        ETCold.ByteHelper.WriteTo(buffer, 9, System.toUInt32(error))
        for i = 0, times - 1 do
          this.socket:SendTo(buffer, 0, 13, SystemNetSockets.SocketFlags.None, address)
        end
      end, function (default)
        local e = default
        ET.Log.Error("Disconnect error " .. localConn .. " " .. remoteConn .. " " .. error .. " " .. System.toString(address) .. " " .. System.toString(e))
      end)
      if default then
        return
      end

      ET.Log.Info("channel send fin: " .. localConn .. " " .. remoteConn .. " " .. System.toString(address) .. " " .. error)
    end
    Send = function (this, channelId, actorId, stream)
      local channel = Get1(this, channelId)
      if channel == nil then
        return
      end
      channel:Send(actorId, stream)
    end
    AddToUpdateNextTime = function (this, time, id)
      if time == 0 then
        this.updateChannels:Add(id)
        return
      end
      if time < this.minTime then
        this.minTime = time
      end
      this.timeId:Add(time, id)
    end
    Update = function (this)
      Recv(this)

      TimerOut(this)

      for _, id in System.each(this.updateChannels) do
        local continue
        repeat
          local kChannel = Get1(this, id)
          if kChannel == nil then
            continue = true
            break
          end

          if kChannel.Id == 0 then
            continue = true
            break
          end

          kChannel:Update()
          continue = true
        until 1
        if not continue then
          break
        end
      end

      this.updateChannels:Clear()

      RemoveConnectTimeoutChannels(this)
    end
    RemoveConnectTimeoutChannels = function (this)
      System.using(ListComponent_1Int64.Create(), function (waitRemoveChannels)
        for _, channelId in System.each(this.waitConnectChannels:getKeys()) do
          local continue
          repeat
            local _, kChannel = this.waitConnectChannels:TryGetValue(channelId)
            if kChannel == nil then
              ET.Log.Error("RemoveConnectTimeoutChannels not found kchannel: " .. channelId)
              continue = true
              break
            end

            -- 连接上了要马上删除
            if kChannel.IsConnected then
              waitRemoveChannels.List:Add(channelId)
            end

            -- 10秒连接超时
            if getTimeNow(this) > kChannel.CreateTime + 10000 --[[10 * 1000]] then
              waitRemoveChannels.List:Add(channelId)
            end
            continue = true
          until 1
          if not continue then
            break
          end
        end

        for _, channelId in System.each(waitRemoveChannels.List) do
          this.waitConnectChannels:RemoveKey(channelId)
        end
      end)
    end
    TimerOut = function (this)
      if this.timeId:getCount() == 0 then
        return
      end

      local timeNow = getTimeNow(this)

      if timeNow < this.minTime then
        return
      end

      this.timeOutTime:Clear()

      for _, kv in System.each(this.timeId) do
        local k = kv.Key
        if k > timeNow then
          this.minTime = k
          break
        end

        this.timeOutTime:Add(k)
      end

      for _, k in System.each(this.timeOutTime) do
        for _, v in System.each(this.timeId:get1(k)) do
          this.updateChannels:Add(v)
        end

        this.timeId:RemoveKey(k)
      end
    end
    return {
      base = function (out)
        return {
          out.ET.AService
        }
      end,
      startTime = 0,
      getTimeNow = getTimeNow,
      ChangeAddress = ChangeAddress,
      minTime = 0,
      IsDispose = IsDispose,
      Dispose = Dispose,
      Get1 = Get1,
      Get = Get,
      Remove = Remove,
      Send = Send,
      AddToUpdateNextTime = AddToUpdateNextTime,
      Update = Update,
      static = static,
      __ctor__ = {
        __ctor1__,
        __ctor2__
      },
      __metadata__ = function (out)
        return {
          fields = {
            { "cache", 0x1, System.Array(System.Byte) },
            { "idChannels", 0x1, System.Dictionary(System.Int64, out.ET.KChannel) },
            { "ipEndPoint", 0x1, System.Net.EndPoint },
            { "localConnChannels", 0x1, System.Dictionary(System.Int64, out.ET.KChannel) },
            { "logBuffer", 0x9, System.Array(System.Byte) },
            { "minTime", 0x1, System.Int64 },
            { "socket", 0x1, System.Net.Sockets.Socket },
            { "startTime", 0x1, System.Int64 },
            { "timeId", 0x1, out.ET.MultiMap_2(System.Int64, System.Int64) },
            { "timeOutTime", 0x1, System.List(System.Int64) },
            { "updateChannels", 0x1, System.HashSet(System.Int64) },
            { "waitConnectChannels", 0x1, System.Dictionary(System.Int64, out.ET.KChannel) }
          },
          properties = {
            { "TimeNow", 0x206, System.UInt32, getTimeNow }
          },
          methods = {
            { ".ctor", 0x306, __ctor1__, out.ETCold.ThreadSynchronizationContext, System.Net.IPEndPoint, out.ET.ServiceType },
            { ".ctor", 0x206, __ctor2__, out.ETCold.ThreadSynchronizationContext, out.ET.ServiceType },
            { "AddToUpdateNextTime", 0x206, AddToUpdateNextTime, System.Int64, System.Int64 },
            { "ChangeAddress", 0x206, ChangeAddress, System.Int64, System.Net.IPEndPoint },
            { "CloneAddress", 0x81, CloneAddress, System.Net.IPEndPoint },
            { "Disconnect", 0x501, Disconnect, System.UInt32, System.UInt32, System.Int32, System.Net.IPEndPoint, System.Int32 },
            { "Dispose", 0x6, Dispose },
            { "Get", 0x186, Get1, System.Int64, out.ET.KChannel },
            { "Get", 0x203, Get, System.Int64, System.Net.IPEndPoint },
            { "GetByLocalConn", 0x181, GetByLocalConn, System.UInt32, out.ET.KChannel },
            { "IsDispose", 0x86, IsDispose, System.Boolean },
            { "KcpLog", 0x409, KcpLog, System.IntPtr, System.Int32, System.IntPtr, System.IntPtr },
            { "KcpOutput", 0x489, KcpOutput, System.IntPtr, System.Int32, System.IntPtr, System.IntPtr, System.Int32 },
            { "Recv", 0x1, Recv },
            { "Remove", 0x106, Remove, System.Int64 },
            { "RemoveConnectTimeoutChannels", 0x1, RemoveConnectTimeoutChannels },
            { "Send", 0x303, Send, System.Int64, System.Int64, System.IO.MemoryStream },
            { "TimerOut", 0x1, TimerOut },
            { "Update", 0x6, Update }
          },
          class = { 0x6 }
        }
      end
    }
  end)
end)
