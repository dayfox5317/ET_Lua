-- Generated by CSharp.lua Compiler
local System = System
local ETCold = ETCold
local SystemIO = System.IO
local SystemNetSockets = System.Net.Sockets
local SystemInteropServices = System.Runtime.InteropServices
local ArrayByte = System.Array(System.Byte)
local ET
local DictIntPtrKChannel
local QueueKcpWaitPacket
System.import(function (out)
  ET = out.ET
  DictIntPtrKChannel = System.Dictionary(System.IntPtr, ET.KChannel)
  QueueKcpWaitPacket = System.Queue(ET.KcpWaitPacket)
end)
System.namespace("ET", function (namespace)
  namespace.struct("KcpWaitPacket", function (namespace)
    return {
      ActorId = 0,
      __metadata__ = function (out)
        return {
          fields = {
            { "ActorId", 0x6, System.Int64 },
            { "MemoryStream", 0x6, System.IO.MemoryStream }
          },
          class = { 0x6 }
        }
      end
    }
  end)

  namespace.class("KChannel", function (namespace)
    local KcpPtrChannels, InitKcp, Dispose, HandleConnnect, Connect, Update, HandleRecv, Output, 
    KcpSend, Send, OnRead, OnError, static, internal, __ctor1__, __ctor2__
    static = function (this)
      KcpPtrChannels = DictIntPtrKChannel()
      this.KcpPtrChannels = KcpPtrChannels
    end
    internal = function (this)
      this.kcp = System.default(System.IntPtr)
      this.sendBuffer = QueueKcpWaitPacket()
      this.sendCache = ArrayByte:new(2048 --[[2 * 1024]])
      this.ms = SystemIO.MemoryStream(10000 --[[KChannel.maxPacketSize]])
    end
    __ctor1__ = function (this, id, localConn, socket, remoteEndPoint, kService)
      internal(this)
      this.LocalConn = localConn

      this.Id = id
      this.ChannelType = ET.ChannelType.Connect

      ET.Log.Info("channel create: " .. this.Id .. " " .. this.LocalConn .. " " .. System.toString(remoteEndPoint) .. " " .. this.ChannelType:EnumToString(ET.ChannelType))

      this.kcp = System.IntPtr.Zero
      this.Service = kService
      this.RemoteAddress = remoteEndPoint
      this.socket = socket
      this.lastRecvTime = kService:getTimeNow()
      this.CreateTime = kService:getTimeNow()

      Connect(this)
    end
    __ctor2__ = function (this, id, localConn, remoteConn, socket, remoteEndPoint, kService)
      internal(this)
      this.Id = id
      this.ChannelType = ET.ChannelType.Accept

      ET.Log.Info("channel create: " .. this.Id .. " " .. localConn .. " " .. remoteConn .. " " .. System.toString(remoteEndPoint) .. " " .. this.ChannelType:EnumToString(ET.ChannelType))

      this.Service = kService
      this.LocalConn = localConn
      this.RemoteConn = remoteConn
      this.RemoteAddress = remoteEndPoint
      this.socket = socket
      this.kcp = ETCold.Kcp.KcpCreate(this.RemoteConn, System.IntPtr.Zero)
      InitKcp(this)

      this.lastRecvTime = kService:getTimeNow()
      this.CreateTime = kService:getTimeNow()
    end
    InitKcp = function (this)
      KcpPtrChannels:AddKeyValue(this.kcp, this)
      repeat
        local default = this.Service.ServiceType
        if default == ET.ServiceType.Inner then
          ETCold.Kcp.KcpNodelay(this.kcp, 1, 10, 2, 1)
          ETCold.Kcp.KcpWndsize(this.kcp, 65535 --[[UInt16.MaxValue]], 65535 --[[UInt16.MaxValue]])
          ETCold.Kcp.KcpSetmtu(this.kcp, 1400)
          -- 默认1400
          ETCold.Kcp.KcpSetminrto(this.kcp, 30)
          break
        elseif default == ET.ServiceType.Outer then
          ETCold.Kcp.KcpNodelay(this.kcp, 1, 10, 2, 1)
          ETCold.Kcp.KcpWndsize(this.kcp, 256, 256)
          ETCold.Kcp.KcpSetmtu(this.kcp, 470)
          ETCold.Kcp.KcpSetminrto(this.kcp, 30)
          break
        end
      until 1
    end
    Dispose = function (this)
      if this:getIsDisposed() then
        return
      end

      local localConn = this.LocalConn
      local remoteConn = this.RemoteConn
      ET.Log.Info("channel dispose: " .. this.Id .. " " .. localConn .. " " .. remoteConn)

      local id = this.Id
      this.Id = 0
      this.Service:Remove(id)

      System.try(function ()
        --this.Service.Disconnect(localConn, remoteConn, this.Error, this.RemoteAddress, 3);
      end, function (default)
        local e = default
        ET.Log.Error1(e)
      end)

      if this.kcp ~= System.IntPtr.Zero then
        KcpPtrChannels:RemoveKey(this.kcp)
        ETCold.Kcp.KcpRelease(this.kcp)
        this.kcp = System.IntPtr.Zero
      end

      this.socket = nil
    end
    HandleConnnect = function (this)
      -- 如果连接上了就不用处理了
      if this.IsConnected then
        return
      end

      this.kcp = ETCold.Kcp.KcpCreate(this.RemoteConn, System.IntPtr.Zero)
      InitKcp(this)

      ET.Log.Info("channel connected: " .. this.Id .. " " .. this.LocalConn .. " " .. this.RemoteConn .. " " .. System.toString(this.RemoteAddress))
      this.IsConnected = true
      this.lastRecvTime = this.Service:getTimeNow()

      while true do
        if #this.sendBuffer <= 0 then
          break
        end

        local buffer = this.sendBuffer:Dequeue()
        KcpSend(this, buffer:__clone__())
      end
    end
    -- <summary>
    -- 发送请求连接消息
    -- </summary>
    Connect = function (this)
      System.try(function ()
        local timeNow = this.Service:getTimeNow()

        this.lastRecvTime = timeNow

        local buffer = this.sendCache
        ETCold.ByteHelper.WriteTo(buffer, 0, 1 --[[KcpProtocalType.SYN]])
        ETCold.ByteHelper.WriteTo(buffer, 1, this.LocalConn)
        ETCold.ByteHelper.WriteTo(buffer, 5, this.RemoteConn)
        this.socket:SendTo(buffer, 0, 9, SystemNetSockets.SocketFlags.None, this.RemoteAddress)
        ET.Log.Info("kchannel connect " .. this.Id .. " " .. this.LocalConn .. " " .. this.RemoteConn .. " " .. this.RealAddress .. " " .. System.toString(this.socket:getLocalEndPoint()))

        -- 300毫秒后再次update发送connect请求
        this.Service:AddToUpdateNextTime(timeNow + 300, this.Id)
      end, function (default)
        local e = default
        ET.Log.Error1(e)
        OnError(this, 100209 --[[ErrorCode.ERR_SocketCantSend]])
      end)
    end
    Update = function (this)
      if this:getIsDisposed() then
        return
      end

      local timeNow = this.Service:getTimeNow()

      -- 如果还没连接上，发送连接请求
      if not this.IsConnected then
        -- 10秒超时没连接上则报错
        if timeNow - this.CreateTime > 10000 then
          ET.Log.Error("kChannel connect timeout: " .. this.Id .. " " .. this.RemoteConn .. " " .. timeNow .. " " .. this.CreateTime .. " " .. this.ChannelType:EnumToString(ET.ChannelType) .. " " .. System.toString(this.RemoteAddress))
          OnError(this, 100205 --[[ErrorCode.ERR_KcpConnectTimeout]])
          return
        end
        repeat
          local default = this.ChannelType
          if default == ET.ChannelType.Connect then
            Connect(this)
            break
          end
        until 1
        return
      end

      if this.kcp == System.IntPtr.Zero then
        return
      end

      local default = System.try(function ()
        ETCold.Kcp.KcpUpdate(this.kcp, timeNow)
      end, function (default)
        local e = default
        ET.Log.Error1(e)
        OnError(this, 100210 --[[ErrorCode.ERR_SocketError]])
        return true
      end)
      if default then
        return
      end

      local nextUpdateTime = ETCold.Kcp.KcpCheck(this.kcp, timeNow)
      this.Service:AddToUpdateNextTime(nextUpdateTime, this.Id)
    end
    HandleRecv = function (this, date, offset, length)
      if this:getIsDisposed() then
        return
      end

      this.IsConnected = true

      ETCold.Kcp.KcpInput(this.kcp, date, offset, length)
      this.Service:AddToUpdateNextTime(0, this.Id)

      while true do
        local continue
        repeat
          if this:getIsDisposed() then
            break
          end
          local n = ETCold.Kcp.KcpPeeksize(this.kcp)
          if n < 0 then
            break
          end
          if n == 0 then
            OnError(this, 10052 --[[(int)SocketError.NetworkReset]])
            return
          end


          if this.needReadSplitCount > 0 then
            local buffer = this.readMemory:GetBuffer()
            local count = ETCold.Kcp.KcpRecv(this.kcp, buffer, System.toInt32(this.readMemory:getLength()) - this.needReadSplitCount, n)
            this.needReadSplitCount = this.needReadSplitCount - count
            if n ~= count then
              ET.Log.Error("kchannel read error1: " .. this.LocalConn .. " " .. this.RemoteConn)
              OnError(this, 100230 --[[ErrorCode.ERR_KcpReadNotSame]])
              return
            end

            if this.needReadSplitCount < 0 then
              ET.Log.Error("kchannel read error2: " .. this.LocalConn .. " " .. this.RemoteConn)
              OnError(this, 100231 --[[ErrorCode.ERR_KcpSplitError]])
              return
            end

            -- 没有读完
            if this.needReadSplitCount ~= 0 then
              continue = true
              break
            end
          else
            this.readMemory = this.ms
            this.readMemory:SetLength(n)
            this.readMemory:Seek(0, SystemIO.SeekOrigin.Begin)

            local buffer = this.readMemory:GetBuffer()
            local count = ETCold.Kcp.KcpRecv(this.kcp, buffer, 0, n)
            if n ~= count then
              break
            end

            -- 判断是不是分片
            if n == 8 then
              local headInt = System.BitConverter.ToInt32(this.readMemory:GetBuffer(), 0)
              if headInt == 0 then
                this.needReadSplitCount = System.BitConverter.ToInt32(this.readMemory:GetBuffer(), 4)
                if this.needReadSplitCount <= 10000 --[[KChannel.maxPacketSize]] then
                  ET.Log.Error("kchannel read error3: " .. this.needReadSplitCount .. " " .. this.LocalConn .. " " .. this.RemoteConn)
                  OnError(this, 100232 --[[ErrorCode.ERR_KcpSplitCountError]])
                  return
                end
                this.readMemory = SystemIO.MemoryStream(this.needReadSplitCount)
                this.readMemory:SetLength(this.needReadSplitCount)
                this.readMemory:Seek(0, SystemIO.SeekOrigin.Begin)
                continue = true
                break
              end
            end
          end


          repeat
            local default = this.Service.ServiceType
            if default == ET.ServiceType.Inner then
              this.readMemory:Seek(10 --[[Packet.ActorIdLength + Packet.OpcodeLength]], SystemIO.SeekOrigin.Begin)
              break
            elseif default == ET.ServiceType.Outer then
              this.readMemory:Seek(2 --[[Packet.OpcodeLength]], SystemIO.SeekOrigin.Begin)
              break
            end
          until 1
          this.lastRecvTime = this.Service:getTimeNow()
          local mem = this.readMemory
          this.readMemory = nil
          OnRead(this, mem)
          continue = true
        until 1
        if not continue then
          break
        end
      end
    end
    Output = function (this, bytes, count)
      if this:getIsDisposed() then
        return
      end
      local default = System.try(function ()
        -- 没连接上 kcp不往外发消息, 其实本来没连接上不会调用update，这里只是做一层保护
        if not this.IsConnected then
          return true
        end

        if count == 0 then
          ET.Log.Error("output 0" .. "")
          return true
        end

        local buffer = this.sendCache
        ETCold.ByteHelper.WriteTo(buffer, 0, 4 --[[KcpProtocalType.MSG]])
        -- 每个消息头部写下该channel的id;
        ETCold.ByteHelper.WriteTo(buffer, 1, this.LocalConn)
        SystemInteropServices.Marshal.Copy(bytes, buffer, 5, count)
        this.socket:SendTo(buffer, 0, count + 5, SystemNetSockets.SocketFlags.None, this.RemoteAddress)
      end, function (default)
        local e = default
        ET.Log.Error1(e)
        OnError(this, 100209 --[[ErrorCode.ERR_SocketCantSend]])
      end)
      if default then
        return
      end
    end
    KcpSend = function (this, kcpWaitPacket)
      if this:getIsDisposed() then
        return
      end

      local memoryStream = kcpWaitPacket.MemoryStream
      local count = System.toInt32(memoryStream:getLength() - memoryStream:getPosition())

      if this.Service.ServiceType == ET.ServiceType.Inner then
        ETCold.ByteHelper.WriteTo(memoryStream:GetBuffer(), 0, kcpWaitPacket.ActorId)
      end

      -- 超出maxPacketSize需要分片
      if count <= 10000 --[[KChannel.maxPacketSize]] then
        ETCold.Kcp.KcpSend(this.kcp, memoryStream:GetBuffer(), System.toInt32(memoryStream:getPosition()), count)
      else
        -- 先发分片信息
        ETCold.ByteHelper.WriteTo(this.sendCache, 0, 0)
        ETCold.ByteHelper.WriteTo(this.sendCache, 4, count)
        ETCold.Kcp.KcpSend(this.kcp, this.sendCache, 0, 8)

        -- 分片发送
        local alreadySendCount = 0
        while alreadySendCount < count do
          local leftCount = count - alreadySendCount

          local sendCount = (leftCount < 10000 --[[KChannel.maxPacketSize]]) and leftCount or 10000 --[[KChannel.maxPacketSize]]

          ETCold.Kcp.KcpSend(this.kcp, memoryStream:GetBuffer(), System.toInt32(memoryStream:getPosition()) + alreadySendCount, sendCount)

          alreadySendCount = alreadySendCount + sendCount
        end
      end

      this.Service:AddToUpdateNextTime(0, this.Id)
    end
    Send = function (this, actorId, stream)
      if this.kcp ~= System.IntPtr.Zero then
        -- 检查等待发送的消息，如果超出最大等待大小，应该断开连接
        local n = ETCold.Kcp.KcpWaitsnd(this.kcp)

        local maxWaitSize = 0
        repeat
          local default = this.Service.ServiceType
          if default == ET.ServiceType.Inner then
            maxWaitSize = 1048576 --[[Kcp.InnerMaxWaitSize]]
            break
          elseif default == ET.ServiceType.Outer then
            maxWaitSize = 1048576 --[[Kcp.OuterMaxWaitSize]]
            break
          else
            System.throw(System.ArgumentOutOfRangeException())
          end
        until 1

        if n > maxWaitSize then
          ET.Log.Error("kcp wait snd too large: " .. n .. ": " .. this.Id .. " " .. this.LocalConn .. " " .. this.RemoteConn)
          OnError(this, 100211 --[[ErrorCode.ERR_KcpWaitSendSizeTooLarge]])
          return
        end
      end

      local default = ET.KcpWaitPacket()
      default.ActorId = actorId
      default.MemoryStream = stream
      local kcpWaitPacket = default
      if not this.IsConnected then
        this.sendBuffer:Enqueue(kcpWaitPacket:__clone__())
        return
      end
      KcpSend(this, kcpWaitPacket:__clone__())
    end
    OnRead = function (this, memoryStream)
      this.Service:OnRead(this.Id, memoryStream)
    end
    OnError = function (this, error)
      local channelId = this.Id
      this.Service:Remove(channelId)
      this.Service:OnError(channelId, error)
    end
    return {
      base = function (out)
        return {
          out.ET.AChannel
        }
      end,
      lastRecvTime = 0,
      CreateTime = 0,
      LocalConn = 0,
      RemoteConn = 0,
      IsConnected = false,
      needReadSplitCount = 0,
      Dispose = Dispose,
      HandleConnnect = HandleConnnect,
      Update = Update,
      HandleRecv = HandleRecv,
      Output = Output,
      Send = Send,
      OnError = OnError,
      static = static,
      __ctor__ = {
        __ctor1__,
        __ctor2__
      },
      __metadata__ = function (out)
        return {
          fields = {
            { "CreateTime", 0x6, System.UInt32 },
            { "KcpPtrChannels", 0xE, System.Dictionary(System.IntPtr, out.ET.KChannel) },
            { "lastRecvTime", 0x1, System.UInt32 },
            { "ms", 0x1, System.IO.MemoryStream },
            { "needReadSplitCount", 0x1, System.Int32 },
            { "readMemory", 0x1, System.IO.MemoryStream },
            { "sendBuffer", 0x1, System.Queue(out.ET.KcpWaitPacket) },
            { "sendCache", 0x1, System.Array(System.Byte) },
            { "Service", 0x6, out.ET.KService },
            { "socket", 0x1, System.Net.Sockets.Socket }
          },
          properties = {
            { "IsConnected", 0x6, System.Boolean },
            { "kcp", 0x6, System.IntPtr },
            { "LocalConn", 0x6, System.UInt32 },
            { "RealAddress", 0x6, System.String },
            { "RemoteConn", 0x6, System.UInt32 }
          },
          methods = {
            { ".ctor", 0x506, __ctor1__, System.Int64, System.UInt32, System.Net.Sockets.Socket, System.Net.IPEndPoint, out.ET.KService },
            { ".ctor", 0x606, __ctor2__, System.Int64, System.UInt32, System.UInt32, System.Net.Sockets.Socket, System.Net.IPEndPoint, out.ET.KService },
            { "Connect", 0x1, Connect },
            { "Dispose", 0x6, Dispose },
            { "HandleConnnect", 0x6, HandleConnnect },
            { "HandleRecv", 0x306, HandleRecv, System.Array(System.Byte), System.Int32, System.Int32 },
            { "InitKcp", 0x1, InitKcp },
            { "KcpSend", 0x101, KcpSend, out.ET.KcpWaitPacket },
            { "OnError", 0x106, OnError, System.Int32 },
            { "OnRead", 0x101, OnRead, System.IO.MemoryStream },
            { "Output", 0x206, Output, System.IntPtr, System.Int32 },
            { "Send", 0x206, Send, System.Int64, System.IO.MemoryStream },
            { "Update", 0x6, Update }
          },
          class = { 0x6 }
        }
      end
    }
  end)
end)
