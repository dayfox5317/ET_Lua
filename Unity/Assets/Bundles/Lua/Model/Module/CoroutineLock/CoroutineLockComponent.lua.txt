-- Generated by CSharp.lua Compiler
local System = System
local Linq = System.Linq.Enumerable
local ET = ET
local QueueInt64 = System.Queue(System.Int64)
local ET
local QueueValueTuple
local ETTask_1CoroutineLock
local QueueCoroutineLockTimer
local MultiMap_2Int64CoroutineLockTimer
local SortedDictionary_2Int32ETTask_1CoroutineLock
local QueueSortedDictionary_2Int32ETTask_1CoroutineLock
local DictInt64SortedDictionary_2Int32ETTask_1CoroutineLock
local ListDictInt64SortedDictionary_2Int32ETTask_1CoroutineLock
System.import(function (out)
  ET = out.ET
  QueueValueTuple = System.Queue(System.ValueTuple)
  ETTask_1CoroutineLock = ET.ETTask_1(ET.CoroutineLock)
  QueueCoroutineLockTimer = System.Queue(ET.CoroutineLockTimer)
  MultiMap_2Int64CoroutineLockTimer = ET.MultiMap_2(System.Int64, ET.CoroutineLockTimer)
  SortedDictionary_2Int32ETTask_1CoroutineLock = System.SortedDictionary_2(System.Int32, ETTask_1CoroutineLock)
  QueueSortedDictionary_2Int32ETTask_1CoroutineLock = System.Queue(SortedDictionary_2Int32ETTask_1CoroutineLock)
  DictInt64SortedDictionary_2Int32ETTask_1CoroutineLock = System.Dictionary(System.Int64, SortedDictionary_2Int32ETTask_1CoroutineLock)
  ListDictInt64SortedDictionary_2Int32ETTask_1CoroutineLock = System.List(DictInt64SortedDictionary_2Int32ETTask_1CoroutineLock)
end)
System.namespace("ET", function (namespace)
  namespace.struct("CoroutineLockTimer", function (namespace)
    local __ctor__
    __ctor__ = function (this, coroutineLockType, key, n)
      this.CoroutineLockType = ET.CoroutineLockType.None
      if coroutineLockType == nil then
        return
      end
      this.CoroutineLockType = coroutineLockType
      this.Key = key
      this.N = n
    end
    return {
      Key = 0,
      N = 0,
      __ctor__ = __ctor__,
      __metadata__ = function (out)
        return {
          fields = {
            { "CoroutineLockType", 0x6, out.ET.CoroutineLockType },
            { "Key", 0x6, System.Int64 },
            { "N", 0x6, System.Int32 }
          },
          methods = {
            { ".ctor", 0x306, __ctor__, out.ET.CoroutineLockType, System.Int64, System.Int32 }
          },
          class = { 0x6 }
        }
      end
    }
  end)

  namespace.class("CoroutineLockComponentSystem", function (namespace)
    local Awake
    Awake = function (this, self)
      self:Awake()
    end
    return {
      base = function (out)
        return {
          out.ET.AwakeSystem_1(out.ET.CoroutineLockComponent)
        }
      end,
      Awake = Awake,
      __metadata__ = function (out)
        return {
          methods = {
            { "Awake", 0x106, Awake, out.ET.CoroutineLockComponent }
          },
          class = { 0x6, out.ET.ObjectSystemAttribute() }
        }
      end
    }
  end)

  namespace.class("CoroutineLockComponentUpdateSystem", function (namespace)
    local Update
    Update = function (this, self)
      self:Update()
    end
    return {
      base = function (out)
        return {
          out.ET.UpdateSystem_1(out.ET.CoroutineLockComponent)
        }
      end,
      Update = Update,
      __metadata__ = function (out)
        return {
          methods = {
            { "Update", 0x106, Update, out.ET.CoroutineLockComponent }
          },
          class = { 0x6 }
        }
      end
    }
  end)

  namespace.class("CoroutineLockComponent", function (namespace)
    local FetchCoroutineLockQueue, RecycleCoroutineLockQueue, Awake, Update, TimeoutCheck, Dispose, Wait, GetCount, 
    Notify, class, __ctor__
    __ctor__ = function (this)
      this.coroutineLockQueuePool = QueueSortedDictionary_2Int32ETTask_1CoroutineLock()
      this.list = ListDictInt64SortedDictionary_2Int32ETTask_1CoroutineLock(51 --[[(int) CoroutineLockType.Max]])
      this.nextFrameRun = QueueValueTuple()
      this.timers = MultiMap_2Int64CoroutineLockTimer()
      this.timeOutIds = QueueInt64()
      this.timerOutTimer = QueueCoroutineLockTimer()
      ET.Entity.__ctor__(this)
    end
    FetchCoroutineLockQueue = function (this)
      if #this.coroutineLockQueuePool == 0 then
        return SortedDictionary_2Int32ETTask_1CoroutineLock()
      end

      return this.coroutineLockQueuePool:Dequeue()
    end
    RecycleCoroutineLockQueue = function (this, coroutineLockQueue)
      this.coroutineLockQueuePool:Enqueue(coroutineLockQueue)
    end
    Awake = function (this)
      class.Instance = this
      for i = 0, this.list:getCapacity() - 1 do
        this.list:Add(DictInt64SortedDictionary_2Int32ETTask_1CoroutineLock())
      end
    end
    Update = function (this)
      local count = #this.nextFrameRun
      -- 注意这里不能将this.nextFrameRun.Count 放到for循环中，因为循环过程中会有对象继续加入队列
      for i = 0, count - 1 do
        local coroutineLockType, key = this.nextFrameRun:Dequeue():Deconstruct()
        Notify(this, coroutineLockType, key, 1)
      end

      TimeoutCheck(this)
    end
    TimeoutCheck = function (this)
      -- 超时的锁
      if this.timers:getCount() == 0 then
        return
      end

      local timeNow = ET.TimeHelper.ClientFrameTime()

      if timeNow < this.minTime then
        return
      end

      for _, kv in System.each(this.timers) do
        local k = kv.Key
        if k > timeNow then
          this.minTime = k
          break
        end

        this.timeOutIds:Enqueue(k)
      end

      this.timerOutTimer:Clear()

      while #this.timeOutIds > 0 do
        local time = this.timeOutIds:Dequeue()
        for _, coroutineLockTimer in System.each(this.timers:get1(time)) do
          this.timerOutTimer:Enqueue(coroutineLockTimer:__clone__())
        end
        this.timers:RemoveKey(time)
      end

      while #this.timerOutTimer > 0 do
        local continue
        repeat
          local coroutineLockTimer = this.timerOutTimer:Dequeue()

          local coroutineLockQueueType = this.list:get(System.Convert.ToInt32(coroutineLockTimer.CoroutineLockType))
          local default, queue = coroutineLockQueueType:TryGetValue(coroutineLockTimer.Key)
          if not default then
            continue = true
            break
          end
          local extern, tcs = queue:TryGetValue(coroutineLockTimer.N)
          if not extern then
            continue = true
            break
          end

          queue:RemoveKey(coroutineLockTimer.N)

          if queue:getCount() == 0 then
            RecycleCoroutineLockQueue(this, queue)
            coroutineLockQueueType:RemoveKey(coroutineLockTimer.Key)
          end

          local coroutineLockType = coroutineLockTimer.CoroutineLockType
          local key = coroutineLockTimer.Key

          tcs:SetException(System.Exception("coroutineLock timeout maybe have deadlock: " .. coroutineLockType:EnumToString(ET.CoroutineLockType) .. " " .. key))
          continue = true
        until 1
        if not continue then
          break
        end
      end
    end
    Dispose = function (this)
      if this:getIsDisposed() then
        return
      end

      ET.Entity.Dispose(this)

      this.list:Clear()
    end
    Wait = function (this, coroutineLockType, key, time)
      return System.async(function (async, this, coroutineLockType, key, time)
        local coroutineLockQueueType = this.list:get(System.Convert.ToInt32(coroutineLockType))
        local default, queue = coroutineLockQueueType:TryGetValue(key)
        if not default then
          coroutineLockQueueType:AddKeyValue(key, FetchCoroutineLockQueue(this))

          return ET.CoroutineLock(this, coroutineLockType, key, 1)
        end

        local tcs = ETTask_1CoroutineLock.Create(true)

        local extern = this.n + 1
        this.n = extern
        local i = extern
        if time > 0 then
          local tillTime = ET.TimeHelper.ClientFrameTime() + time
          local coroutineLockTimer = ET.CoroutineLockTimer(coroutineLockType, key, i)
          this.timers:Add(tillTime, coroutineLockTimer:__clone__())
          if tillTime < this.minTime then
            this.minTime = tillTime
          end
        end
        queue:AddKeyValue(i, tcs)
        return async:Await(tcs)
      end, nil, this, coroutineLockType, key, time)
    end
    GetCount = function (this, coroutineLockType, key)
      local coroutineLockQueueType = this.list:get(System.Convert.ToInt32(coroutineLockType))
      local default, queue = coroutineLockQueueType:TryGetValue(key)
      if not default then
        return 0
      end

      return queue:getCount()
    end
    Notify = function (this, coroutineLockType, key, index)
      if #this.list == 0 then
        return
      end
      local coroutineLockQueueType = this.list:get(System.Convert.ToInt32(coroutineLockType))
      local default, queue = coroutineLockQueueType:TryGetValue(key)
      if not default then
        return
        -- coroutineLockQueueType是空的也正常，因为有些协程锁可能超时删除了
        --throw new Exception($"first work notify not find queue");
      end

      if queue:getCount() == 0 then
        RecycleCoroutineLockQueue(this, queue)
        coroutineLockQueueType:RemoveKey(key)
        return
      end

      -- 注意因为协程锁Dispose会调用下一个协程，如果队列过多，堆栈可能溢出，所以这里限制了一次最多递归10层，
      -- 超出则记录一下，下一帧再继续
      if index > 10 then
        this.nextFrameRun:Enqueue(System.ValueTuple(coroutineLockType, key))
        return
      end

      local kv = Linq.First(queue)
      local tcs = kv.Value
      queue:RemoveKey(kv.Key)
      tcs:SetResult(ET.CoroutineLock(this, coroutineLockType, key, System.toInt16(index + 1)))
    end
    class = {
      base = function (out)
        return {
          out.ET.Entity
        }
      end,
      n = 0,
      minTime = 0,
      Awake = Awake,
      Update = Update,
      Dispose = Dispose,
      Wait = Wait,
      GetCount = GetCount,
      Notify = Notify,
      __ctor__ = __ctor__,
      __metadata__ = function (out)
        return {
          properties = {
            { "Instance", 0xE, class }
          },
          fields = {
            { "coroutineLockQueuePool", 0x1, System.Queue(System.SortedDictionary_2(System.Int32, out.ET.ETTask_1(out.ET.CoroutineLock))) },
            { "list", 0x1, System.List(System.Dictionary(System.Int64, System.SortedDictionary_2(System.Int32, out.ET.ETTask_1(out.ET.CoroutineLock)))) },
            { "minTime", 0x1, System.Int64 },
            { "n", 0x1, System.Int32 },
            { "nextFrameRun", 0x1, System.Queue(System.ValueTuple) },
            { "timeOutIds", 0x1, System.Queue(System.Int64) },
            { "timerOutTimer", 0x1, System.Queue(out.ET.CoroutineLockTimer) },
            { "timers", 0x1, out.ET.MultiMap_2(System.Int64, out.ET.CoroutineLockTimer) }
          },
          methods = {
            { "Awake", 0x6, Awake },
            { "Dispose", 0x6, Dispose },
            { "FetchCoroutineLockQueue", 0x81, FetchCoroutineLockQueue, System.SortedDictionary_2(System.Int32, out.ET.ETTask_1(out.ET.CoroutineLock)) },
            { "GetCount", 0x286, GetCount, out.ET.CoroutineLockType, System.Int64, System.Int32 },
            { "Notify", 0x306, Notify, out.ET.CoroutineLockType, System.Int64, System.Int16 },
            { "RecycleCoroutineLockQueue", 0x101, RecycleCoroutineLockQueue, System.SortedDictionary_2(System.Int32, out.ET.ETTask_1(out.ET.CoroutineLock)) },
            { "TimeoutCheck", 0x1, TimeoutCheck },
            { "Update", 0x6, Update },
            { "Wait", 0x386, Wait, out.ET.CoroutineLockType, System.Int64, System.Int32, out.ET.ETTask_1(out.ET.CoroutineLock) }
          },
          class = { 0x6 }
        }
      end
    }
    return class
  end)
end)
