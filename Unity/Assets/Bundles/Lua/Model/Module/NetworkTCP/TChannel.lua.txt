-- Generated by CSharp.lua Compiler
local System = System
local ETCold = ETCold
local SystemNet = System.Net
local SystemNetSockets = System.Net.Sockets
local ArrayByte = System.Array(System.Byte)
local ET
System.import(function (out)
  ET = out.ET
end)
System.namespace("ET", function (namespace)
  -- <summary>
  -- 封装Socket,将回调push到主线程处理
  -- </summary>
  namespace.class("TChannel", function (namespace)
    local OnComplete, Dispose, Send, ConnectAsync, OnConnectComplete, OnDisconnectComplete, StartRecv, OnRecvComplete, 
    HandleRecv, Update, StartSend, OnSendComplete, HandleSend, OnRead, OnError, internal, 
    __ctor1__, __ctor2__
    internal = function (this)
      this.innArgs = SystemNetSockets.SocketAsyncEventArgs()
      this.outArgs = SystemNetSockets.SocketAsyncEventArgs()
      this.recvBuffer = ETCold.CircularBuffer()
      this.sendBuffer = ETCold.CircularBuffer()
      this.sendCache = ArrayByte:new(10 --[[Packet.OpcodeLength + Packet.ActorIdLength]])
    end
    __ctor1__ = function (this, id, ipEndPoint, service)
      internal(this)
      this.ChannelType = ET.ChannelType.Connect
      this.Id = id
      this.Service = service
      this.socket = SystemNetSockets.Socket(SystemNetSockets.AddressFamily.InterNetwork, SystemNetSockets.SocketType.Stream, SystemNetSockets.ProtocolType.Tcp)
      this.socket:setNoDelay(true)
      this.parser = ET.PacketParser(this.recvBuffer, this.Service)
      this.innArgs:addCompleted(System.fn(this, OnComplete))
      this.outArgs:addCompleted(System.fn(this, OnComplete))

      this.RemoteAddress = ipEndPoint
      this.isConnected = false
      this.isSending = false

      this.Service.ThreadSynchronizationContext:PostNext(System.fn(this, ConnectAsync))
    end
    __ctor2__ = function (this, id, socket, service)
      internal(this)
      this.ChannelType = ET.ChannelType.Accept
      this.Id = id
      this.Service = service
      this.socket = socket
      this.socket:setNoDelay(true)
      this.parser = ET.PacketParser(this.recvBuffer, this.Service)
      this.innArgs:addCompleted(System.fn(this, OnComplete))
      this.outArgs:addCompleted(System.fn(this, OnComplete))

      this.RemoteAddress = System.cast(SystemNet.IPEndPoint, socket:getRemoteEndPoint())
      this.isConnected = true
      this.isSending = false

      -- 下一帧再开始读写
      this.Service.ThreadSynchronizationContext:PostNext(function ()
        StartRecv(this)
        StartSend(this)
      end)
    end
    OnComplete = function (this, sender, e)
      repeat
        local default = e:getLastOperation()
        if default == SystemNetSockets.SocketAsyncOperation.Connect then
          this.Service.ThreadSynchronizationContext:Post(function ()
            OnConnectComplete(this, e)
          end)
          break
        elseif default == SystemNetSockets.SocketAsyncOperation.Receive then
          this.Service.ThreadSynchronizationContext:Post(function ()
            OnRecvComplete(this, e)
          end)
          break
        elseif default == SystemNetSockets.SocketAsyncOperation.Send then
          this.Service.ThreadSynchronizationContext:Post(function ()
            OnSendComplete(this, e)
          end)
          break
        elseif default == SystemNetSockets.SocketAsyncOperation.Disconnect then
          this.Service.ThreadSynchronizationContext:Post(function ()
            OnDisconnectComplete(this, e)
          end)
          break
        else
          System.throw(System.Exception("socket error: " .. e:getLastOperation():EnumToString(SystemNetSockets.SocketAsyncOperation)))
        end
      until 1
    end
    Dispose = function (this)
      if this:getIsDisposed() then
        return
      end

      ET.Log.Info("channel dispose: " .. this.Id .. " " .. System.toString(this.RemoteAddress))

      local id = this.Id
      this.Id = 0
      this.Service:Remove(id)
      this.socket:Close()
      this.innArgs:Dispose()
      this.outArgs:Dispose()
      this.innArgs = nil
      this.outArgs = nil
      this.socket = nil
    end
    Send = function (this, actorId, stream)
      if this:getIsDisposed() then
        System.throw(System.Exception("TChannel已经被Dispose, 不能发送消息"))
      end

      repeat
        local default = this.Service.ServiceType
        if default == ET.ServiceType.Inner then
          local messageSize = System.toInt32(stream:getLength() - stream:getPosition())
          if messageSize > 1048560 --[[ushort.MaxValue * 16]] then
            System.throw(System.Exception("send packet too large: " .. stream:getLength() .. " " .. stream:getPosition()))
          end

          ETCold.ByteHelper.WriteTo(this.sendCache, 0, messageSize)
          this.sendBuffer:Write(this.sendCache, 0, 4 --[[PacketParser.InnerPacketSizeLength]])

          -- actorId
          ETCold.ByteHelper.WriteLongTo(stream:GetBuffer(), 0, actorId)
          this.sendBuffer:Write(stream:GetBuffer(), System.toInt32(stream:getPosition()), System.toInt32(stream:getLength() - stream:getPosition()))
          break
        elseif default == ET.ServiceType.Outer then
          local messageSize = System.toUInt16(stream:getLength() - stream:getPosition())


          this.sendBuffer:WriteUshort(messageSize)
          this.sendBuffer:Write(stream)

          break
        end
      until 1


      if not this.isSending then
        --this.StartSend();
        this.Service.NeedStartSend:Add(this.Id)
      end
    end
    ConnectAsync = function (this)
      this.outArgs:setRemoteEndPoint(this.RemoteAddress)
      if this.socket:ConnectAsync(this.outArgs) then
        return
      end
      OnConnectComplete(this, this.outArgs)
    end
    OnConnectComplete = function (this, o)
      if this.socket == nil then
        return
      end
      local e = System.cast(SystemNetSockets.SocketAsyncEventArgs, o)

      if e:getSocketError() ~= SystemNetSockets.SocketError.Success then
        OnError(this, System.Convert.ToInt32(e:getSocketError()))
        return
      end

      e:setRemoteEndPoint(nil)
      this.isConnected = true
      StartRecv(this)
      StartSend(this)
    end
    OnDisconnectComplete = function (this, o)
      local e = System.cast(SystemNetSockets.SocketAsyncEventArgs, o)
      OnError(this, System.Convert.ToInt32(e:getSocketError()))
    end
    StartRecv = function (this)
      while true do
        local default = System.try(function ()
          if this.socket == nil then
            return true
          end

          local size = this.recvBuffer.ChunkSize - this.recvBuffer:getLastIndex()
          this.innArgs:SetBuffer(this.recvBuffer:getLast(), this.recvBuffer:getLastIndex(), size)
        end, function (default)
          local e = default
          ET.Log.Error("tchannel error: " .. this.Id .. "\n" .. System.toString(e))
          OnError(this, 100214 --[[ErrorCode.ERR_TChannelRecvError]])
          return true
        end)
        if default then
          return
        end

        if this.socket:ReceiveAsync(this.innArgs) then
          return
        end
        HandleRecv(this, this.innArgs)
      end
    end
    OnRecvComplete = function (this, o)
      HandleRecv(this, o)

      if this.socket == nil then
        return
      end
      StartRecv(this)
    end
    HandleRecv = function (this, o)
      if this.socket == nil then
        return
      end
      local e = System.cast(SystemNetSockets.SocketAsyncEventArgs, o)

      if e:getSocketError() ~= SystemNetSockets.SocketError.Success then
        OnError(this, System.Convert.ToInt32(e:getSocketError()))
        return
      end

      if e:getBytesTransferred() == 0 then
        OnError(this, 100208 --[[ErrorCode.ERR_PeerDisconnect]])
        return
      end

      this.recvBuffer:Write(e:getBuffer(), e:getOffset(), e:getBytesTransferred())
      if this.recvBuffer:getLastIndex() == this.recvBuffer.ChunkSize then
        this.recvBuffer:AddLast()
        this.recvBuffer:setLastIndex(0)
      end

      -- 收到消息回调
      while true do
        -- 这里循环解析消息执行，有可能，执行消息的过程中断开了session
        if this.socket == nil then
          return
        end
        local default = System.try(function ()
          local ret = this.parser:Parse()
          if not ret then
            return false
          end

          OnRead(this, this.parser.MemoryStream)
        end, function (default)
          local ee = default
          ET.Log.Error("ip: " .. System.toString(this.RemoteAddress) .. " " .. System.toString(ee))
          OnError(this, 100210 --[[ErrorCode.ERR_SocketError]])
          return true
        end)
        if default then
          return
        elseif default == false then
          break
        end
      end
    end
    Update = function (this)
      StartSend(this)
    end
    StartSend = function (this)
      if not this.isConnected then
        return
      end

      while true do
        local default = System.try(function ()
          if this.socket == nil then
            return true
          end

          -- 没有数据需要发送
          if this.sendBuffer:getLength() == 0 then
            this.isSending = false
            return true
          end

          this.isSending = true

          local sendSize = this.sendBuffer.ChunkSize - this.sendBuffer:getFirstIndex()
          if sendSize > this.sendBuffer:getLength() then
            sendSize = System.toInt32(this.sendBuffer:getLength())
          end

          this.outArgs:SetBuffer(this.sendBuffer:getFirst(), this.sendBuffer:getFirstIndex(), sendSize)

          if this.socket:SendAsync(this.outArgs) then
            return true
          end

          HandleSend(this, this.outArgs)
        end, function (default)
          local e = default
          System.throw(System.Exception("socket set buffer error: " .. #this.sendBuffer:getFirst() .. ", " .. this.sendBuffer:getFirstIndex(), e))
        end)
        if default then
          return
        end
      end
    end
    OnSendComplete = function (this, o)
      HandleSend(this, o)

      StartSend(this)
    end
    HandleSend = function (this, o)
      if this.socket == nil then
        return
      end

      local e = System.cast(SystemNetSockets.SocketAsyncEventArgs, o)

      if e:getSocketError() ~= SystemNetSockets.SocketError.Success then
        OnError(this, System.Convert.ToInt32(e:getSocketError()))
        return
      end

      if e:getBytesTransferred() == 0 then
        OnError(this, 100208 --[[ErrorCode.ERR_PeerDisconnect]])
        return
      end

      this.sendBuffer:setFirstIndex(this.sendBuffer:getFirstIndex() + e:getBytesTransferred())
      if this.sendBuffer:getFirstIndex() == this.sendBuffer.ChunkSize then
        this.sendBuffer:setFirstIndex(0)
        this.sendBuffer:RemoveFirst()
      end
    end
    OnRead = function (this, memoryStream)
      System.try(function ()
        local channelId = this.Id
        this.Service:OnRead(channelId, memoryStream)
      end, function (default)
        local e = default
        ET.Log.Error(System.toString(this.RemoteAddress) .. " " .. memoryStream:getLength() .. " " .. System.toString(e))
        -- 出现任何消息解析异常都要断开Session，防止客户端伪造消息
        OnError(this, 110005 --[[ErrorCode.ERR_PacketParserError]])
      end)
    end
    OnError = function (this, error)
      ET.Log.Info("TChannel OnError: " .. error .. " " .. System.toString(this.RemoteAddress))

      local channelId = this.Id

      this.Service:Remove(channelId)

      this.Service:OnError(channelId, error)
    end
    return {
      base = function (out)
        return {
          out.ET.AChannel
        }
      end,
      isSending = false,
      isConnected = false,
      Dispose = Dispose,
      Send = Send,
      Update = Update,
      __ctor__ = {
        __ctor1__,
        __ctor2__
      },
      __metadata__ = function (out)
        return {
          fields = {
            { "innArgs", 0x1, System.Net.Sockets.SocketAsyncEventArgs },
            { "isConnected", 0x1, System.Boolean },
            { "isSending", 0x1, System.Boolean },
            { "outArgs", 0x1, System.Net.Sockets.SocketAsyncEventArgs },
            { "parser", 0x1, out.ET.PacketParser },
            { "recvBuffer", 0x1, out.ETCold.CircularBuffer },
            { "sendBuffer", 0x1, out.ETCold.CircularBuffer },
            { "sendCache", 0x1, System.Array(System.Byte) },
            { "Service", 0x1, out.ET.TService },
            { "socket", 0x1, System.Net.Sockets.Socket }
          },
          methods = {
            { ".ctor", 0x306, __ctor1__, System.Int64, System.Net.IPEndPoint, out.ET.TService },
            { ".ctor", 0x306, __ctor2__, System.Int64, System.Net.Sockets.Socket, out.ET.TService },
            { "ConnectAsync", 0x1, ConnectAsync },
            { "Dispose", 0x6, Dispose },
            { "HandleRecv", 0x101, HandleRecv, System.Object },
            { "HandleSend", 0x101, HandleSend, System.Object },
            { "OnComplete", 0x201, OnComplete, System.Object, System.Net.Sockets.SocketAsyncEventArgs },
            { "OnConnectComplete", 0x101, OnConnectComplete, System.Object },
            { "OnDisconnectComplete", 0x101, OnDisconnectComplete, System.Object },
            { "OnError", 0x101, OnError, System.Int32 },
            { "OnRead", 0x101, OnRead, System.IO.MemoryStream },
            { "OnRecvComplete", 0x101, OnRecvComplete, System.Object },
            { "OnSendComplete", 0x101, OnSendComplete, System.Object },
            { "Send", 0x206, Send, System.Int64, System.IO.MemoryStream },
            { "StartRecv", 0x1, StartRecv },
            { "StartSend", 0x1, StartSend },
            { "Update", 0x6, Update }
          },
          class = { 0x6 }
        }
      end
    }
  end)
end)
