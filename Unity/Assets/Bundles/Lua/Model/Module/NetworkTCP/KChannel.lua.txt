-- Generated by CSharp.lua Compiler
local System = System
local ETCold = ETCold
local SystemIO = System.IO
local SystemNetSockets = System.Net.Sockets
local ArrayByte = System.Array(System.Byte)
local DictInt64UInt64 = System.Dictionary(System.Int64, System.UInt64)
local ET
local DictUInt32KChannel
local QueueKcpWaitPacket
System.import(function (out)
  ET = out.ET
  DictUInt32KChannel = System.Dictionary(System.UInt32, ET.KChannel)
  QueueKcpWaitPacket = System.Queue(ET.KcpWaitPacket)
end)
System.namespace("ET", function (namespace)
  namespace.struct("KcpWaitPacket", function (namespace)
    return {
      ActorId = 0,
      __metadata__ = function (out)
        return {
          fields = {
            { "ActorId", 0x6, System.Int64 },
            { "MemoryStream", 0x6, System.IO.MemoryStream }
          },
          class = { 0x6 }
        }
      end
    }
  end)

  namespace.class("KChannel", function (namespace)
    local kChannels, idLocalRemoteConn, InitKcp, Dispose, HandleConnnect, Connect, Update, HandleRecv, 
    Output_Safe, KcpSend, Send, OnRead, OnError, static, internal, __ctor1__, 
    __ctor2__
    static = function (this)
      kChannels = DictUInt32KChannel()
      this.kChannels = kChannels
      idLocalRemoteConn = DictInt64UInt64()
      this.idLocalRemoteConn = idLocalRemoteConn
    end
    internal = function (this)
      this.sendBuffer = QueueKcpWaitPacket()
      this.sendCache = ArrayByte:new(1048576 --[[1024 * 1024]])
    end
    __ctor1__ = function (this, id, localConn, socket, remoteEndPoint, kService)
      internal(this)
      this.LocalConn = localConn
      if kChannels:ContainsKey(this.LocalConn) then
        System.throw(System.Exception("channel create error: " .. this.LocalConn .. " " .. System.toString(remoteEndPoint) .. " " .. this.ChannelType:EnumToString(ET.ChannelType)))
      end

      this.Id = id
      this.ChannelType = ET.ChannelType.Connect

      ET.Log.Info("channel create: " .. this.Id .. " " .. this.LocalConn .. " " .. System.toString(remoteEndPoint) .. " " .. this.ChannelType:EnumToString(ET.ChannelType))

      this.Service = kService
      this.RemoteAddress = remoteEndPoint
      this.socket = socket
      this.kcp = ETCold.KcpWraper(this.RemoteConn, localConn)
      -- Kcp.KcpCreate(this.RemoteConn, (IntPtr) this.LocalConn);

      kChannels:AddKeyValue(this.LocalConn, this)

      this.lastRecvTime = kService:getTimeNow()
      this.CreateTime = kService:getTimeNow()

      Connect(this)
    end
    __ctor2__ = function (this, id, localConn, remoteConn, socket, remoteEndPoint, kService)
      internal(this)
      if kChannels:ContainsKey(this.LocalConn) then
        System.throw(System.Exception("channel create error: " .. localConn .. " " .. System.toString(remoteEndPoint) .. " " .. this.ChannelType:EnumToString(ET.ChannelType)))
      end

      this.Id = id
      this.ChannelType = ET.ChannelType.Accept

      ET.Log.Info("channel create: " .. this.Id .. " " .. localConn .. " " .. remoteConn .. " " .. System.toString(remoteEndPoint) .. " " .. this.ChannelType:EnumToString(ET.ChannelType))

      this.Service = kService
      this.LocalConn = localConn
      this.RemoteConn = remoteConn
      this.RemoteAddress = remoteEndPoint
      this.socket = socket
      this.kcp = ETCold.KcpWraper(remoteConn, localConn)
      -- Kcp.KcpCreate(this.RemoteConn, (IntPtr) localConn);

      kChannels:AddKeyValue(this.LocalConn, this)

      this.lastRecvTime = kService:getTimeNow()
      this.CreateTime = kService:getTimeNow()

      InitKcp(this)
    end
    InitKcp = function (this)
      repeat
        local default = this.Service.ServiceType
        if default == ET.ServiceType.Inner then
          this.kcp:Nodelay(1, 10, 2, 1)
          this.kcp:WndSize(102400 --[[1024 * 100]], 102400 --[[1024 * 100]])
          this.kcp:Setmtu(1400)
          -- 默认1400
          this.kcp:Setminrto(10)
          break
        elseif default == ET.ServiceType.Outer then
          this.kcp:Nodelay(1, 10, 2, 1)
          this.kcp:WndSize(128, 128)
          this.kcp:Setmtu(470)
          this.kcp:Setminrto(10)
          break
        end
      until 1
    end
    Dispose = function (this)
      if this:getIsDisposed() then
        return
      end

      local localConn = this.LocalConn
      local remoteConn = this.RemoteConn
      ET.Log.Info("channel dispose: " .. this.Id .. " " .. localConn .. " " .. remoteConn)

      kChannels:RemoveKey(localConn)
      idLocalRemoteConn:RemoveKey(this.Id)
      -- idLocalRemoteConn.TryRemove(this.Id, out ulong _);

      local id = this.Id
      this.Id = 0
      this.Service:Remove(id)

      System.try(function ()
        --this.Service.Disconnect(localConn, remoteConn, this.Error, this.RemoteAddress, 3);
      end, function (default)
        local e = default
        ET.Log.Error1(e)
      end)

      if this.kcp:IsEnable() then
        this.kcp:Release()
        -- Kcp.KcpRelease(this.kcp);
        this.kcp = nil
        -- IntPtr.Zero;
      end

      this.socket = nil
    end
    HandleConnnect = function (this)
      -- 如果连接上了就不用处理了
      if this.IsConnected then
        return
      end

      this.kcp = ETCold.KcpWraper(this.RemoteConn, this.LocalConn)
      -- Kcp.KcpCreate(this.RemoteConn, new IntPtr(this.LocalConn));
      InitKcp(this)

      local localRmoteConn = System.bor((System.sl(this.RemoteConn, 32)), this.LocalConn)
      idLocalRemoteConn:set(this.Id, localRmoteConn)
      -- idLocalRemoteConn.TryAdd(this.Id, localRmoteConn);

      ET.Log.Info("channel connected: " .. this.Id .. " " .. this.LocalConn .. " " .. this.RemoteConn .. " " .. System.toString(this.RemoteAddress))
      this.IsConnected = true
      this.lastRecvTime = this.Service:getTimeNow()

      while true do
        if #this.sendBuffer <= 0 then
          break
        end

        local buffer = this.sendBuffer:Dequeue()
        KcpSend(this, buffer:__clone__())
      end
    end
    -- <summary>
    -- 发送请求连接消息
    -- </summary>
    Connect = function (this)
      System.try(function ()
        local timeNow = this.Service:getTimeNow()

        this.lastRecvTime = timeNow

        local buffer = this.sendCache
        ETCold.ByteHelper.WriteByteTo(buffer, 0, 1 --[[KcpProtocalType.SYN]])
        ETCold.ByteHelper.WriteTo(buffer, 1, this.LocalConn)
        ETCold.ByteHelper.WriteTo(buffer, 5, this.RemoteConn)
        this.socket:SendTo(buffer, 0, 9, SystemNetSockets.SocketFlags.None, this.RemoteAddress)
        ET.Log.Info("kchannel connect " .. this.Id .. " " .. this.LocalConn .. " " .. this.RemoteConn .. " " .. this.RealAddress .. " " .. System.toString(this.socket:getLocalEndPoint()))
        -- 200毫秒后再次update发送connect请求
        this.Service:AddToUpdateNextTime(timeNow + 300, this.Id)
      end, function (default)
        local e = default
        ET.Log.Error1(e)
        OnError(this, 100209 --[[ErrorCode.ERR_SocketCantSend]])
      end)
    end
    Update = function (this)
      if this:getIsDisposed() then
        return
      end

      local timeNow = this.Service:getTimeNow()

      -- 如果还没连接上，发送连接请求
      if not this.IsConnected then
        -- 20秒没连接上则报错
        if timeNow - this.CreateTime > 10000 --[[10 * 1000]] then
          ET.Log.Error("kChannel connect timeout: " .. this.Id .. " " .. this.RemoteConn .. " " .. timeNow .. " " .. this.CreateTime .. " " .. this.ChannelType:EnumToString(ET.ChannelType) .. " " .. System.toString(this.RemoteAddress))
          OnError(this, 100205 --[[ErrorCode.ERR_KcpConnectTimeout]])
          return
        end

        repeat
          local default = this.ChannelType
          if default == ET.ChannelType.Connect then
            Connect(this)
            break
          end
        until 1
        return
      end

      local default = System.try(function ()
        this.kcp:Update(timeNow)
        --Kcp.KcpUpdate(this.kcp, timeNow);
      end, function (default)
        local e = default
        ET.Log.Error1(e)
        OnError(this, 100210 --[[ErrorCode.ERR_SocketError]])
        return true
      end)
      if default then
        return
      end

      if this.kcp:IsEnable() then
        local nextUpdateTime = this.kcp:Check(timeNow)
        -- Kcp.KcpCheck(this.kcp, timeNow);
        this.Service:AddToUpdateNextTime(nextUpdateTime, this.Id)
      end
    end
    HandleRecv = function (this, data, offset, length)
      if this:getIsDisposed() then
        return
      end

      this.IsConnected = true

      this.kcp:Input(data, offset, length)
      --Kcp.KcpInput(this.kcp, date, offset, length);
      this.Service:AddToUpdateNextTime(0, this.Id)

      while true do
        if this:getIsDisposed() then
          break
        end
        local n = this.kcp:Peeksize()
        -- Kcp.KcpPeeksize(this.kcp);
        if n < 0 then
          break
        end
        if n == 0 then
          OnError(this, 10052 --[[(int)SocketError.NetworkReset]])
          break
        end

        local ms = ET.MessageSerializeHelper.GetStream(n)

        ms:SetLength(n)
        ms:Seek(0, SystemIO.SeekOrigin.Begin)
        local buffer = ms:GetBuffer()
        local count = this.kcp:Recv(buffer, n)
        -- Kcp.KcpRecv(this.kcp, buffer, n);
        if n ~= count then
          break
        end

        repeat
          local default = this.Service.ServiceType
          if default == ET.ServiceType.Inner then
            ms:Seek(10 --[[Packet.ActorIdLength + Packet.OpcodeLength]], SystemIO.SeekOrigin.Begin)
            break
          elseif default == ET.ServiceType.Outer then
            ms:Seek(2 --[[Packet.OpcodeLength]], SystemIO.SeekOrigin.Begin)
            break
          end
        until 1
        this.lastRecvTime = this.Service:getTimeNow()
        OnRead(this, ms)
      end
    end
    Output_Safe = function (this, bytes)
      if this:getIsDisposed() then
        return
      end
      local default = System.try(function ()
        -- 没连接上 kcp不往外发消息, 其实本来没连接上不会调用update，这里只是做一层保护
        if not this.IsConnected then
          return true
        end

        if #bytes == 0 then
          ET.Log.Error("output 0" .. "")
          return true
        end

        local buffer = this.sendCache
        ETCold.ByteHelper.WriteByteTo(buffer, 0, 4 --[[KcpProtocalType.MSG]])
        -- 每个消息头部写下该channel的id;
        ETCold.ByteHelper.WriteTo(buffer, 1, this.LocalConn)
        System.Array.Copy(bytes, 0, buffer, 5, #bytes)
        --	Marshal.Copy(bytes, buffer, 5, count);
        this.socket:SendTo(buffer, 0, #bytes + 5, SystemNetSockets.SocketFlags.None, this.RemoteAddress)
      end, function (default)
        local e = default
        ET.Log.Error1(e)
        OnError(this, 100209 --[[ErrorCode.ERR_SocketCantSend]])
      end)
      if default then
        return
      end
    end
    KcpSend = function (this, kcpWaitPacket)
      if this:getIsDisposed() then
        return
      end

      local memoryStream = kcpWaitPacket.MemoryStream
      if this.Service.ServiceType == ET.ServiceType.Inner then
        ETCold.ByteHelper.WriteLongTo(memoryStream:GetBuffer(), 0, kcpWaitPacket.ActorId)
      end

      local count = System.toInt32(memoryStream:getLength() - memoryStream:getPosition())
      this.kcp:Send(memoryStream:GetBuffer(), System.toInt32(memoryStream:getPosition()), count)
      --Kcp.KcpSend(this.kcp, memoryStream.GetBuffer(), (int)memoryStream.Position, count);
      this.Service:AddToUpdateNextTime(0, this.Id)
    end
    Send = function (this, actorId, stream)
      if this.kcp:IsEnable() then
        -- 检查等待发送的消息，如果超出最大等待大小，应该断开连接
        local n = this.kcp:Waitsnd()
        -- Kcp.KcpWaitsnd(this.kcp);

        local maxWaitSize = 0
        repeat
          local default = this.Service.ServiceType
          if default == ET.ServiceType.Inner then
            maxWaitSize = 1048576 --[[Kcp.InnerMaxWaitSize]]
            break
          elseif default == ET.ServiceType.Outer then
            maxWaitSize = 10240 --[[Kcp.OuterMaxWaitSize]]
            break
          else
            System.throw(System.ArgumentOutOfRangeException())
          end
        until 1

        if n > maxWaitSize then
          ET.Log.Error("kcp wait snd too large: " .. n .. ": " .. this.Id .. " " .. this.RemoteConn)
          OnError(this, 100211 --[[ErrorCode.ERR_KcpWaitSendSizeTooLarge]])
          return
        end
      end

      local default = ET.KcpWaitPacket()
      default.ActorId = actorId
      default.MemoryStream = stream
      local kcpWaitPacket = default
      if not this.IsConnected then
        this.sendBuffer:Enqueue(kcpWaitPacket:__clone__())
        return
      end
      KcpSend(this, kcpWaitPacket:__clone__())
    end
    OnRead = function (this, memoryStream)
      this.Service:OnRead(this.Id, memoryStream)
    end
    OnError = function (this, error)
      local channelId = this.Id
      this.Service:Remove(channelId)
      this.Service:OnError(channelId, error)
    end
    return {
      base = function (out)
        return {
          out.ET.AChannel
        }
      end,
      lastRecvTime = 0,
      CreateTime = 0,
      LocalConn = 0,
      RemoteConn = 0,
      IsConnected = false,
      Dispose = Dispose,
      HandleConnnect = HandleConnnect,
      Update = Update,
      HandleRecv = HandleRecv,
      Output_Safe = Output_Safe,
      Send = Send,
      OnError = OnError,
      static = static,
      __ctor__ = {
        __ctor1__,
        __ctor2__
      },
      __metadata__ = function (out)
        return {
          fields = {
            { "CreateTime", 0x6, System.UInt32 },
            { "idLocalRemoteConn", 0xE, System.Dictionary(System.Int64, System.UInt64) },
            { "kChannels", 0xE, System.Dictionary(System.UInt32, out.ET.KChannel) },
            { "kcp", 0x1, out.ETCold.KcpWraper },
            { "lastRecvTime", 0x1, System.UInt32 },
            { "sendBuffer", 0x1, System.Queue(out.ET.KcpWaitPacket) },
            { "sendCache", 0x1, System.Array(System.Byte) },
            { "Service", 0x6, out.ET.KService },
            { "socket", 0x1, System.Net.Sockets.Socket }
          },
          properties = {
            { "IsConnected", 0x6, System.Boolean },
            { "LocalConn", 0x6, System.UInt32 },
            { "RealAddress", 0x6, System.String },
            { "RemoteConn", 0x6, System.UInt32 }
          },
          methods = {
            { ".ctor", 0x506, __ctor1__, System.Int64, System.UInt32, System.Net.Sockets.Socket, System.Net.IPEndPoint, out.ET.KService },
            { ".ctor", 0x606, __ctor2__, System.Int64, System.UInt32, System.UInt32, System.Net.Sockets.Socket, System.Net.IPEndPoint, out.ET.KService },
            { "Connect", 0x1, Connect },
            { "Dispose", 0x6, Dispose },
            { "HandleConnnect", 0x6, HandleConnnect },
            { "HandleRecv", 0x306, HandleRecv, System.Array(System.Byte), System.Int32, System.Int32 },
            { "InitKcp", 0x1, InitKcp },
            { "KcpSend", 0x101, KcpSend, out.ET.KcpWaitPacket },
            { "OnError", 0x106, OnError, System.Int32 },
            { "OnRead", 0x101, OnRead, System.IO.MemoryStream },
            { "Output_Safe", 0x106, Output_Safe, System.Array(System.Byte) },
            { "Send", 0x206, Send, System.Int64, System.IO.MemoryStream },
            { "Update", 0x6, Update }
          },
          class = { 0x6 }
        }
      end
    }
  end)
end)
