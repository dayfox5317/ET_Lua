-- Generated by CSharp.lua Compiler
local System = System
local ETCold = ETCold
local SystemIO = System.IO
local ET
System.import(function (out)
  ET = out.ET
end)
System.namespace("ET", function (namespace)
  namespace.enum("ParserState", function ()
    local class
    class = {
      PacketSize = 0,
      PacketBody = 1,
      __metadata__ = function (out)
        return {
          fields = {
            { "PacketBody", 0xE, class },
            { "PacketSize", 0xE, class }
          },
          class = { 0x6 }
        }
      end
    }
    return class
  end)

  namespace.class("PacketParser", function (namespace)
    local Parse, __ctor__
    __ctor__ = function (this, buffer, service)
      this.state = ET.ParserState.PacketSize
      this.buffer = buffer
      this.service = service
      this.cacheMemoryStream = SystemIO.MemoryStream(8)
    end
    Parse = function (this)
      while true do
        repeat
          local default = this.state
          if default == ET.ParserState.PacketSize then
            if this.service.ServiceType == ET.ServiceType.Inner then
              if this.buffer:getLength() < 4 --[[PacketParser.InnerPacketSizeLength]] then
                return false
              end


              this.cacheMemoryStream:setPosition(0)
              this.buffer:Read(this.cacheMemoryStream, 4 --[[PacketParser.InnerPacketSizeLength]])
              this.packetSize = ETCold.StreamHelper.ToInt32(this.cacheMemoryStream, 0)
              if this.packetSize > 1048560 --[[ushort.MaxValue * 16]] or this.packetSize < 2 --[[Packet.MinPacketSize]] then
                System.throw(System.Exception("recv packet size error, 可能是外网探测端口: " .. this.packetSize))
              end
            else
              if this.buffer:getLength() < 2 --[[PacketParser.OuterPacketSizeLength]] then
                return false
              end

              this.cacheMemoryStream:setPosition(0)
              this.buffer:Read(this.cacheMemoryStream, 2 --[[PacketParser.OuterPacketSizeLength]])
              this.packetSize = ETCold.StreamHelper.ToUInt16(this.cacheMemoryStream, 0)
              if this.packetSize < 2 --[[Packet.MinPacketSize]] then
                System.throw(System.Exception("recv packet size error, 可能是外网探测端口: " .. this.packetSize))
              end
            end

            this.state = ET.ParserState.PacketBody
            break
          elseif default == ET.ParserState.PacketBody then
            if this.buffer:getLength() < this.packetSize then
              return false
            end

            local memoryStream = ET.MessageSerializeHelper.GetStream(this.packetSize)
            this.buffer:Read(memoryStream, this.packetSize)
            --memoryStream.SetLength(this.packetSize - Packet.MessageIndex);
            this.MemoryStream = memoryStream

            if this.service.ServiceType == ET.ServiceType.Inner then
              memoryStream:Seek(10 --[[Packet.MessageIndex]], SystemIO.SeekOrigin.Begin)
            else
              memoryStream:Seek(2 --[[Packet.OpcodeLength]], SystemIO.SeekOrigin.Begin)
            end

            this.state = ET.ParserState.PacketSize
            return true
          else
            System.throw(System.ArgumentOutOfRangeException())
          end
        until 1
      end
    end
    return {
      packetSize = 0,
      Parse = Parse,
      __ctor__ = __ctor__,
      __metadata__ = function (out)
        return {
          fields = {
            { "buffer", 0x1, out.ETCold.CircularBuffer },
            { "cacheMemoryStream", 0x6, System.IO.MemoryStream },
            { "MemoryStream", 0x6, System.IO.MemoryStream },
            { "packetSize", 0x1, System.Int32 },
            { "service", 0x6, out.ET.AService },
            { "state", 0x1, out.ET.ParserState }
          },
          methods = {
            { ".ctor", 0x206, nil, out.ETCold.CircularBuffer, out.ET.AService },
            { "Parse", 0x86, Parse, System.Boolean }
          },
          class = { 0x6 }
        }
      end
    }
  end)
end)
